diff --git a/keepalived/check/check_daemon.c b/keepalived/check/check_daemon.c
index faacce55..ecc1a590 100644
--- a/keepalived/check/check_daemon.c
+++ b/keepalived/check/check_daemon.c
@@ -52,42 +52,36 @@
 #include "bfd_daemon.h"
 #include "check_bfd.h"
 #endif
+#include "timer.h"
 
 /* Global variables */
 bool using_ha_suspend;
 
 /* local variables */
 static char *check_syslog_ident;
+static bool two_phase_terminate;
 
 static int
 lvs_notify_fifo_script_exit(__attribute__((unused)) thread_t *thread)
 {
 	log_message(LOG_INFO, "lvs notify fifo script terminated");
 
 	return 0;
 }
 
-
-/* Daemon stop sequence */
-static void
-stop_check(int status)
+static int
+terminate_phase2(__attribute__((unused)) thread_t *thread)
 {
-	if (using_ha_suspend || __test_bit(LOG_ADDRESS_CHANGES, &debug))
-		kernel_netlink_close();
-
-	/* Terminate all script process */
-	script_killall(master, SIGTERM);
-
 	/* Remove the notify fifo */
 	notify_fifo_close(&global_data->notify_fifo, &global_data->lvs_notify_fifo);
 
 	/* Destroy master thread */
 	signal_handler_destroy();
 	thread_destroy_master(master);
+	master = NULL;
 	free_checkers_queue();
 	free_ssl();
-	if (!__test_bit(DONT_RELEASE_IPVS_BIT, &debug))
-		clear_services();
+
 	ipvs_stop();
 #ifdef _WITH_SNMP_CHECKER_
 	if (global_data && global_data->enable_snmp_checker)
@@ -125,6 +119,46 @@ stop_check(int status)
 #endif
 	close_std_fd();
 
+	return 0;
+}
+
+static void
+terminate_phase1(void)
+{
+	if (using_ha_suspend || __test_bit(LOG_ADDRESS_CHANGES, &debug))
+		kernel_netlink_close();
+
+	/* Terminate all script processes */
+	if (master->child.count)
+		script_killall(master, SIGTERM, true);
+
+	/* Send shutdown messages */
+	if (!__test_bit(DONT_RELEASE_IPVS_BIT, &debug))
+		clear_services(terminate_phase2);
+}
+
+static int
+start_termination_thread(thread_t * thread)
+{
+	two_phase_terminate = true;
+
+	terminate_phase1();
+
+	/* If there are no child processes, we can terminate immediately */
+	if (!thread->master->child.count)
+		terminate_phase2(thread);
+
+	return 0;
+}
+
+/* Daemon stop sequence */
+static void
+stop_check(int status)
+{
+	terminate_phase1();
+
+	terminate_phase2(NULL);
+
 	exit(status);
 }
 
@@ -223,10 +258,10 @@ reload_check_thread(__attribute__((unused)) thread_t * thread)
 	log_message(LOG_INFO, "Got SIGHUP, reloading checker configuration");
 
 	/* Terminate all script process */
-	script_killall(master, SIGTERM);
+	script_killall(master, SIGTERM, false);
 
 	/* Remove the notify fifo - we don't know if it will be the same after a reload */
 	notify_fifo_close(&global_data->notify_fifo, &global_data->lvs_notify_fifo);
 
 	/* Destroy master thread */
 #ifdef _WITH_BFD_
@@ -270,7 +305,7 @@ static void
 sigend_check(__attribute__((unused)) void *v, __attribute__((unused)) int sig)
 {
 	if (master)
-		thread_add_terminate_event(master);
+		thread_add_start_terminate_event(master, start_termination_thread);
 }
 
 /* CHECK Child signal handling */
@@ -412,7 +447,10 @@ start_check_child(void)
 	launch_scheduler();
 
 	/* Finish healthchecker daemon process */
-	stop_check(EXIT_SUCCESS);
+	if (two_phase_terminate)
+		terminate_phase2(NULL);
+	else
+		stop_check(EXIT_SUCCESS);
 
 	/* unreachable */
 	exit(EXIT_SUCCESS);
diff --git a/keepalived/check/ipwrapper.c b/keepalived/check/ipwrapper.c
index 1dbe98d3..be30a4d9 100644
--- a/keepalived/check/ipwrapper.c
+++ b/keepalived/check/ipwrapper.c
@@ -118,13 +118,17 @@ notify_fifo_rs(virtual_server_t* vs, real_server_t* rs)
 }
 
 static void
-do_vs_notifies(virtual_server_t* vs, bool init, long threshold, long weight_sum)
+do_vs_notifies(virtual_server_t* vs, bool init, long threshold, long weight_sum, int (*end_handler)(thread_t *))
 {
 	notify_script_t *notify_script = vs->quorum_state_up ? vs->notify_quorum_up : vs->notify_quorum_down;
 	char message[80];
 
-	if (notify_script)
-		notify_exec(notify_script);
+	if (notify_script) {
+		if (end_handler)
+			system_call_script(master, child_killed_thread, end_handler, TIMER_HZ, notify_script);
+		else
+			notify_exec(notify_script);
+	}
 
 	notify_fifo_vs(vs);
 
@@ -146,12 +150,16 @@ do_vs_notifies(virtual_server_t* vs, bool init, long threshold, long weight_sum)
 }
 
 static void
-do_rs_notifies(virtual_server_t* vs, real_server_t* rs)
+do_rs_notifies(virtual_server_t* vs, real_server_t* rs, int (*end_handler)(thread_t *))
 {
 	notify_script_t *notify_script = rs->alive ? rs->notify_up : rs->notify_down;
 
-	if (notify_script)
-		notify_exec(notify_script);
+	if (notify_script) {
+		if (end_handler)
+			system_call_script(master, child_killed_thread, end_handler, TIMER_HZ, notify_script);
+		else
+			notify_exec(notify_script);
+	}
 
 	notify_fifo_rs(vs, rs);
 
@@ -165,7 +173,7 @@ do_rs_notifies(virtual_server_t* vs, real_server_t* rs)
 
 /* Remove a realserver IPVS rule */
 static void
-clear_service_rs(virtual_server_t * vs, list l)
+clear_service_rs(virtual_server_t * vs, list l, int (*end_handler)(thread_t *))
 {
 	element e;
 	real_server_t *rs;
@@ -203,7 +211,7 @@ clear_service_rs(virtual_server_t * vs, list l)
 		/* In Omega mode we call VS and RS down notifiers
 		 * all the way down the exit, as necessary.
 		 */
-		do_rs_notifies(vs, rs);
+		do_rs_notifies(vs, rs, end_handler);
 
 		/* Send SMTP alert */
 		smtp_alert(SMTP_MSG_RS_SHUT, FMT_RS(rs, vs), "DOWN", "=> Shutting down <=");
@@ -217,13 +225,13 @@ clear_service_rs(virtual_server_t * vs, list l)
 	if (vs->quorum_state_up &&
 	    (!weight_sum || weight_sum < threshold)) {
 		vs->quorum_state_up = false;
-		do_vs_notifies(vs, false, threshold, weight_sum);
+		do_vs_notifies(vs, false, threshold, weight_sum, end_handler);
 	}
 }
 
 /* Remove a virtualserver IPVS rule */
 static void
-clear_service_vs(virtual_server_t * vs)
+clear_service_vs(virtual_server_t * vs, int (*end_handler)(thread_t *))
 {
 	bool sav_inhibit;
 
@@ -242,7 +250,7 @@ clear_service_vs(virtual_server_t * vs)
 
 	/* Even if the sorry server was configured, if we are using
 	 * inhibit_on_failure, then real servers may be configured. */
-	clear_service_rs(vs, vs->rs);
+	clear_service_rs(vs, vs->rs, end_handler);
 
 	/* The above will handle Omega case for VS as well. */
 
@@ -253,7 +261,7 @@ clear_service_vs(virtual_server_t * vs)
 
 /* IPVS cleaner processing */
 void
-clear_services(void)
+clear_services(int (*end_handler)(thread_t *))
 {
 	element e;
 	virtual_server_t *vs;
@@ -261,13 +269,11 @@ clear_services(void)
 	if (!check_data || !check_data->vs)
 		return;
 
-	for (e = LIST_HEAD(check_data->vs); e; ELEMENT_NEXT(e)) {
-		vs = ELEMENT_DATA(e);
-
+	LIST_FOREACH(check_data->vs, vs, e) {
 		/* Remove the real servers, and clear the vs unless it is
 		 * using a VS group and it is not the last vs of the same
 		 * protocol or address family using the group. */
-		clear_service_vs(vs);
+		clear_service_vs(vs, end_handler);
 	}
 }
 
@@ -405,7 +411,7 @@ update_quorum_state(virtual_server_t * vs, bool init)
 			vs->s_svr->alive = false;
 		}
 
-		do_vs_notifies(vs, init, threshold, weight_sum);
+		do_vs_notifies(vs, init, threshold, weight_sum, NULL);
 
 		return;
 	}
@@ -441,7 +447,7 @@ update_quorum_state(virtual_server_t * vs, bool init)
 			perform_quorum_state(vs, false);
 		}
 
-		do_vs_notifies(vs, init, threshold, weight_sum);
+		do_vs_notifies(vs, init, threshold, weight_sum, NULL);
 	}
 }
 
@@ -472,7 +478,7 @@ perform_svr_state(bool alive, virtual_server_t * vs, real_server_t * rs)
 			return false;
 	}
 	rs->alive = alive;
-	do_rs_notifies(vs, rs);
+	do_rs_notifies(vs, rs, NULL);
 
 	/* We may have changed quorum state. If the quorum wasn't up
 	 * but is now up, this is where the rs is added. */
@@ -770,7 +776,7 @@ clear_diff_rs(virtual_server_t *old_vs, virtual_server_t *new_vs, list old_check
 			migrate_checkers(rs, new_rs, old_checkers_queue);
 		}
 	}
-	clear_service_rs(old_vs, rs_to_remove);
+	clear_service_rs(old_vs, rs_to_remove, false);
 	free_list(&rs_to_remove);
 }
 
@@ -829,7 +835,7 @@ clear_diff_services(list old_checkers_queue)
 				log_message(LOG_INFO, "Removing Virtual Server %s", FMT_VS(vs));
 
 			/* Clear VS entry */
-			clear_service_vs(vs);
+			clear_service_vs(vs, false);
 		} else {
 			/* copy status fields from old VS */
 			SET_ALIVE(new_vs);
diff --git a/keepalived/include/ipwrapper.h b/keepalived/include/ipwrapper.h
index 3734d786..93c1e500 100644
--- a/keepalived/include/ipwrapper.h
+++ b/keepalived/include/ipwrapper.h
@@ -46,7 +46,7 @@ extern void update_svr_wgt(int, virtual_server_t *, real_server_t *, bool);
 extern void set_checker_state(checker_t *, bool);
 extern void update_svr_checker_state(bool, checker_t *);
 extern bool init_services(void);
-extern void clear_services(void);
+extern void clear_services(int (*)(thread_t *));
 extern void set_quorum_states(void);
 extern void clear_diff_services(list);
 extern void link_vsg_to_vs(void);
diff --git a/keepalived/vrrp/vrrp_daemon.c b/keepalived/vrrp/vrrp_daemon.c
index 91af2a83..a2da8e0d 100644
--- a/keepalived/vrrp/vrrp_daemon.c
+++ b/keepalived/vrrp/vrrp_daemon.c
@@ -157,7 +157,7 @@ stop_vrrp(int status)
 #endif
 
 	/* Terminate all script processes */
-	script_killall(master, SIGTERM);
+	script_killall(master, SIGTERM, false);
 
 	/* We mustn't receive a SIGCHLD after master is destroyed */
 	signal_handler_destroy();
@@ -427,7 +427,7 @@ reload_vrrp_thread(__attribute__((unused)) thread_t * thread)
 	SET_RELOAD;
 
 	/* Terminate all script process */
-	script_killall(master, SIGTERM);
+	script_killall(master, SIGTERM, false);
 
 	if (vrrp_data->vrrp_track_files)
 		stop_track_files();
diff --git a/lib/notify.c b/lib/notify.c
index 9c371986..ab5398fd 100644
--- a/lib/notify.c
+++ b/lib/notify.c
@@ -41,6 +41,7 @@
 #include "utils.h"
 #include "parser.h"
 #include "keepalived_magic.h"
+#include "scheduler.h"
 
 /* Default user/group for script execution */
 uid_t default_script_uid;
@@ -375,12 +378,30 @@ system_call_script(thread_master_t *m, int (*func) (thread_t *), void * arg, uns
 	exit(0); /* Script errors aren't server errors */
 }
 
+int
+child_killed_thread(thread_t *thread)
+{
+	thread_master_t *m = thread->master;
+
+	/* If the child didn't die, then force it */
+	if (thread->type == THREAD_CHILD_TIMEOUT)
+		kill(-getpgid(thread->u.c.pid), SIGKILL);
+
+	/* If all children have died, we can now complete the
+	 * termination process */
+	if (!m->child.count)
+		thread_add_terminate_event(m);
+
+	return 0;
+}
+
 void
-script_killall(thread_master_t *m, int signo)
+script_killall(thread_master_t *m, int signo, bool requeue)
 {
-	sigset_t old_set, child_wait;
 	thread_t *thread;
 	pid_t p_pgid, c_pgid;
 		}
 	}
 
+	/* We want to timeout the killed children in 1 second */
+	if (requeue && signo != SIGKILL)
+		thread_children_reschedule(m, child_killed_thread, TIMER_HZ);
+
+#ifndef HAVE_SIGNALFD
 	if (!sigismember(&old_set, SIGCHLD))
 		sigmask_func(SIG_UNBLOCK, &child_wait, NULL);
+#endif
 }
 
 static bool
diff --git a/lib/notify.h b/lib/notify.h
index 88f167bf..1bdddb73 100644
--- a/lib/notify.h
+++ b/lib/notify.h
@@ -94,7 +94,8 @@ extern void notify_fifo_open(notify_fifo_t*, notify_fifo_t*, int (*)(thread_t *)
 extern void notify_fifo_close(notify_fifo_t*, notify_fifo_t*);
 extern int system_call_script(thread_master_t *, int (*)(thread_t *), void *, unsigned long, notify_script_t *);
 extern int notify_exec(const notify_script_t *);
-extern void script_killall(thread_master_t *, int);
+extern int child_killed_thread(thread_t *);
+extern void script_killall(thread_master_t *, int, bool);
 extern int check_script_secure(notify_script_t *, magic_t);
 extern int check_notify_script_secure(notify_script_t **, magic_t);
 extern bool set_default_script_user(const char *, const char *);
diff --git a/lib/scheduler.c b/lib/scheduler.c
index 66102749..c9c9c527 100644
--- a/lib/scheduler.c
+++ b/lib/scheduler.c
@@ -62,6 +62,9 @@ bool snmp_running;		/* True if this process is running SNMP */
 #endif
 int inotify_fd = -1;
 
+/* local variables */
+static bool shutting_down;
+
 #ifdef _WITH_LVS_
 #include "../keepalived/include/check_daemon.h"
 #endif
@@ -631,6 +642,18 @@ thread_add_child(thread_master_t * m, int (*func) (thread_t *)
 	return thread;
 }
 
+void
+thread_children_reschedule(thread_master_t *m, int (*func)(thread_t *), unsigned long timer)
+{
+	thread_t *thread;
+
+	set_time_now();
+	for (thread = m->child.head; thread; thread = thread->next) {
+		thread->func = func;
+		thread->sands = timer_add_long(time_now, timer);
+	}
+}
+
 /* Add simple event thread. */
 thread_t *
 thread_add_event(thread_master_t * m, int (*func) (thread_t *)
@@ -652,19 +675,19 @@ thread_add_event(thread_master_t * m, int (*func) (thread_t *)
 	return thread;
 }
 
-/* Add simple event thread. */
-thread_t *
-thread_add_terminate_event(thread_master_t * m)
+/* Add terminate event thread. */
+static thread_t *
+thread_add_generic_terminate_event(thread_master_t * m, thread_type_t type, int (*func)(thread_t *))
 {
 	thread_t *thread;
 
 	assert(m != NULL);
 
 	thread = thread_new(m);
-	thread->type = THREAD_TERMINATE;
+	thread->type = type;
 	thread->id = 0;
 	thread->master = m;
-	thread->func = NULL;
+	thread->func = func;
 	thread->arg = NULL;
 	thread->u.val = 0;
 	thread_list_add(&m->event, thread);
@@ -672,6 +695,18 @@ thread_add_terminate_event(thread_master_t * m)
 	return thread;
 }
 
+thread_t *
+thread_add_terminate_event(thread_master_t *m)
+{
+	return thread_add_generic_terminate_event(m, THREAD_TERMINATE, NULL);
+}
+
+thread_t *
+thread_add_start_terminate_event(thread_master_t *m, int(*func)(thread_t *))
+{
+	return thread_add_generic_terminate_event(m, THREAD_TERMINATE_START, func);
+}
+
 /* Cancel thread from scheduler. */
 int
 thread_cancel(thread_t * thread)
@@ -838,14 +873,33 @@ retry:	/* When thread can't fetch try to find next thread again. */
 
 		thread->type = THREAD_UNUSED;
 		thread_add_unuse(m, thread);
+
+		/* Check if we are shutting down. This limits what
+		 * thread types will be executed. */
+		if (shutting_down &&
+		    fetch->type != THREAD_TERMINATE)
+			continue;
+
+		if (thread->type == THREAD_TERMINATE_START)
+			shutting_down = true;
+
 		return t;
 	}
 
+if (shutting_down) {
+// only allow child termination/ timeout
+}
 	/* If there is ready threads process them */
 	while ((thread = thread_trim_head(&m->ready))) {
 		*fetch = *thread;
 		thread->type = THREAD_UNUSED;
 		thread_add_unuse(m, thread);
+
+		if (shutting_down &&
+		    fetch->type != THREAD_CHILD &&
+		    fetch->type != THREAD_CHILD_TIMEOUT)
+			continue;
+
 		return fetch;
 	}
 
@@ -976,7 +1030,7 @@ retry:	/* When thread can't fetch try to find next thread again. */
 			timers_done = true;
 	}
 
-	/* Write thead. */
+	/* Write thread. */
 	thread = m->write.head;
 	timers_done = !timer_expired;
 	while (thread && (num_fds || timer_expired)) {
diff --git a/lib/scheduler.h b/lib/scheduler.h
index c2ba823a..9ea30538 100644
--- a/lib/scheduler.h
+++ b/lib/scheduler.h
@@ -43,6 +43,7 @@ typedef enum {
 	THREAD_WRITE_TIMEOUT,
 	THREAD_READ_TIMEOUT,
 	THREAD_CHILD_TIMEOUT,
+	THREAD_TERMINATE_START,
 	THREAD_TERMINATE,
 	THREAD_READY_FD,
 	THREAD_IF_UP,
@@ -142,14 +143,16 @@ extern bool report_child_status(int, pid_t, const char *);
 extern void set_process_track_inotify(void (*)(int));
 extern thread_master_t *thread_make_master(void);
 extern thread_t *thread_add_terminate_event(thread_master_t *);
+extern thread_t *thread_add_start_terminate_event(thread_master_t *, int (*)(thread_t *));
 extern void thread_cleanup_master(thread_master_t *);
 extern void thread_destroy_master(thread_master_t *);
-extern thread_t *thread_add_read(thread_master_t *, int (*func) (thread_t *), void *, int, unsigned long);
+extern thread_t *thread_add_read(thread_master_t *, int (*) (thread_t *), void *, int, unsigned long);
 extern void thread_requeue_read(thread_master_t *, int, unsigned long);
-extern thread_t *thread_add_write(thread_master_t *, int (*func) (thread_t *), void *, int, unsigned long);
-extern thread_t *thread_add_timer(thread_master_t *, int (*func) (thread_t *), void *, unsigned long);
-extern thread_t *thread_add_child(thread_master_t *, int (*func) (thread_t *), void *, pid_t, unsigned long);
-extern thread_t *thread_add_event(thread_master_t *, int (*func) (thread_t *), void *, int);
+extern thread_t *thread_add_write(thread_master_t *, int (*) (thread_t *), void *, int, unsigned long);
+extern thread_t *thread_add_timer(thread_master_t *, int (*) (thread_t *), void *, unsigned long);
+extern thread_t *thread_add_child(thread_master_t *, int (*) (thread_t *), void *, pid_t, unsigned long);
+extern void thread_children_reschedule(thread_master_t *, int (*) (thread_t *), unsigned long);
+extern thread_t *thread_add_event(thread_master_t *, int (*) (thread_t *), void *, int);
 extern int thread_cancel(thread_t *);
 extern void thread_cancel_read(thread_master_t *, int);
 extern thread_t *thread_fetch(thread_master_t *, thread_t *);
