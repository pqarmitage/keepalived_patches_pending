#1 diff --git a/keepalived/check/check_daemon.c b/keepalived/check/check_daemon.c
#1 index 432949c9..81f07e53 100644
#1 --- a/keepalived/check/check_daemon.c
#1 +++ b/keepalived/check/check_daemon.c
#1 @@ -108,6 +108,8 @@ stop_check(int status)
#1  
#1  	closelog();
#1  
#1 +	FREE(config_id);
#1 +
#1  #ifndef _MEM_CHECK_LOG_
#1  	FREE_PTR(check_syslog_ident);
#1  #else
#4 diff --git a/keepalived/check/check_http.c b/keepalived/check/check_http.c
#4 index b13a1af4..316adc94 100644
#4 --- a/keepalived/check/check_http.c
#4 +++ b/keepalived/check/check_http.c
#4 @@ -718,7 +718,7 @@ http_check_thread(thread_t * thread)
#4  	int status;
#4  	unsigned long timeout = 0;
#4  	int ssl_err = 0;
#4 -	int new_req = 0;
#4 +	bool new_req = false;
#4  
#4  	status = tcp_socket_state(thread, http_check_thread);
#4  	switch (status) {
#4 @@ -730,67 +730,66 @@ http_check_thread(thread_t * thread)
#4  		return timeout_epilog(thread, "Timeout connecting");
#4  		break;
#4  
#4 -	case connect_success:{
#4 -			if (!http_get_check->req) {
#4 -				http_get_check->req = (request_t *) MALLOC(sizeof (request_t));
#4 -				new_req = 1;
#4 -			} else
#4 -				new_req = 0;
#4 -
#4 -			if (http_get_check->proto == PROTO_SSL) {
#4 -				timeout = timer_long(thread->sands) - timer_long(time_now);
#4 -				if (thread->type != THREAD_WRITE_TIMEOUT &&
#4 -				    thread->type != THREAD_READ_TIMEOUT)
#4 -					ret = ssl_connect(thread, new_req);
#4 -				else {
#4 -					return timeout_epilog(thread, "Timeout connecting");
#4 -				}
#4 +	case connect_success:
#4 +		if (!http_get_check->req) {
#4 +			http_get_check->req = (request_t *) MALLOC(sizeof (request_t));
#4 +			new_req = true;
#4 +		} else
#4 +			new_req = false;
#4 +
#4 +		if (http_get_check->proto == PROTO_SSL) {
#4 +			timeout = timer_long(thread->sands) - timer_long(time_now);
#4 +			if (thread->type != THREAD_WRITE_TIMEOUT &&
#4 +			    thread->type != THREAD_READ_TIMEOUT)
#4 +				ret = ssl_connect(thread, new_req);
#4 +			else {
#4 +				return timeout_epilog(thread, "Timeout connecting");
#4 +			}
#4  
#4 -				if (ret == -1) {
#4 -					switch ((ssl_err = SSL_get_error(http_get_check->req->ssl,
#4 -									 ret))) {
#4 -					case SSL_ERROR_WANT_READ:
#4 -						thread_add_read(thread->master,
#4 -								http_check_thread,
#4 -								THREAD_ARG(thread),
#4 -								thread->u.fd, timeout);
#4 -						break;
#4 -					case SSL_ERROR_WANT_WRITE:
#4 -						thread_add_write(thread->master,
#4 -								 http_check_thread,
#4 -								 THREAD_ARG(thread),
#4 -								 thread->u.fd, timeout);
#4 -						break;
#4 -					default:
#4 -						ret = 0;
#4 -						break;
#4 -					}
#4 -					if (ret == -1)
#4 -						break;
#4 -				} else if (ret != 1)
#4 +			if (ret == -1) {
#4 +				switch ((ssl_err = SSL_get_error(http_get_check->req->ssl,
#4 +								 ret))) {
#4 +				case SSL_ERROR_WANT_READ:
#4 +					thread_add_read(thread->master,
#4 +							http_check_thread,
#4 +							THREAD_ARG(thread),
#4 +							thread->u.fd, timeout);
#4 +					break;
#4 +				case SSL_ERROR_WANT_WRITE:
#4 +					thread_add_write(thread->master,
#4 +							 http_check_thread,
#4 +							 THREAD_ARG(thread),
#4 +							 thread->u.fd, timeout);
#4 +					break;
#4 +				default:
#4  					ret = 0;
#4 -			}
#4 +					break;
#4 +				}
#4 +				if (ret == -1)
#4 +					break;
#4 +			} else if (ret != 1)
#4 +				ret = 0;
#4 +		}
#4  
#4 -			if (ret) {
#4 -				/* Remote WEB server is connected.
#4 -				 * Register the next step thread ssl_request_thread.
#4 -				 */
#4 -				DBG("Remote Web server %s connected.", FMT_HTTP_RS(checker));
#4 -				thread_add_write(thread->master,
#4 -						 http_request_thread, checker,
#4 -						 thread->u.fd,
#4 -						 checker->co->connection_to);
#4 -			} else {
#4 -				DBG("Connection trouble to: %s."
#4 -						 , FMT_HTTP_RS(checker));
#4 +		if (ret) {
#4 +			/* Remote WEB server is connected.
#4 +			 * Register the next step thread ssl_request_thread.
#4 +			 */
#4 +			DBG("Remote Web server %s connected.", FMT_HTTP_RS(checker));
#4 +			thread_add_write(thread->master,
#4 +					 http_request_thread, checker,
#4 +					 thread->u.fd,
#4 +					 checker->co->connection_to);
#4 +		} else {
#4 +			DBG("Connection trouble to: %s."
#4 +					 , FMT_HTTP_RS(checker));
#4  #ifdef _DEBUG_
#4 -				if (http_get_check->proto == PROTO_SSL)
#4 -					ssl_printerr(SSL_get_error
#4 -						     (req->ssl, ret));
#4 +			if (http_get_check->proto == PROTO_SSL)
#4 +				ssl_printerr(SSL_get_error
#4 +					     (req->ssl, ret));
#4  #endif
#4 -				return timeout_epilog(thread, "SSL handshake/communication error"
#4 -							 " connecting to");
#4 -			}
#4 +			return timeout_epilog(thread, "SSL handshake/communication error"
#4 +						 " connecting to");
#4  		}
#4  		break;
#4  	}
#3 diff --git a/keepalived/check/check_ssl.c b/keepalived/check/check_ssl.c
#3 index 5c9f319d..d0cd6471 100644
#3 --- a/keepalived/check/check_ssl.c
#3 +++ b/keepalived/check/check_ssl.c
#3 @@ -40,9 +40,8 @@
#3  void
#3  clear_ssl(ssl_data_t *ssl)
#3  {
#3 -	if (ssl)
#3 -		if (ssl->ctx)
#3 -			SSL_CTX_free(ssl->ctx);
#3 +	if (ssl && ssl->ctx)
#3 +		SSL_CTX_free(ssl->ctx);
#3  }
#3  
#3  /* PEM password callback function */
#3 @@ -60,17 +59,22 @@ password_cb(char *buf, int num, __attribute__((unused)) int rwflag, void *userda
#3  }
#3  
#3  /* Inititalize global SSL context */
#3 -static BIO *bio_err = 0;
#3 +//static BIO *bio_err = 0;
#3  static int
#3  build_ssl_ctx(void)
#3  {
#3  	ssl_data_t *ssl;
#3  
#3  	/* Library initialization */
#3 +#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
#3  	SSL_library_init();
#3 -
#3  	SSL_load_error_strings();
#3 -	bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
#3 +#else
#3 +	if (!OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG, NULL))
#3 +		log_message(LOG_INFO, "OPENSSL_init_crypto failed");
#3 +#endif
#3 +
#3 +//	bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
#3  
#3  	if (!check_data->ssl)
#3  		ssl = (ssl_data_t *) MALLOC(sizeof(ssl_data_t));
#3 @@ -154,9 +158,6 @@ init_ssl_ctx(void)
#3  int
#3  ssl_printerr(int err)
#3  {
#3 -	unsigned long extended_error = 0;
#3 -	char *ssl_strerr;
#3 -
#3  	switch (err) {
#3  	case SSL_ERROR_ZERO_RETURN:
#3  		log_message(LOG_INFO, "  SSL error: (zero return)");
#3 @@ -176,15 +177,10 @@ ssl_printerr(int err)
#3  	case SSL_ERROR_SYSCALL:
#3  		log_message(LOG_INFO, "  SSL error: (syscall error)");
#3  		break;
#3 -	case SSL_ERROR_SSL:{
#3 -			ssl_strerr = (char *) MALLOC(500);
#3 -
#3 -			extended_error = ERR_get_error();
#3 -			ERR_error_string(extended_error, ssl_strerr);
#3 -			log_message(LOG_INFO, "  SSL error: (%s)", ssl_strerr);
#3 -			FREE(ssl_strerr);
#3 -			break;
#3 -		}
#3 +	case SSL_ERROR_SSL:
#3 +		/* Note: the following is not thread safe. Use MALLOC(256) and ERR_error_string_n if need thread safety */
#3 +		log_message(LOG_INFO, "  SSL error: (%s)", ERR_error_string(ERR_get_error(), NULL));
#3 +		break;
#3  	}
#3  	return 0;
#3  }
#3 @@ -205,6 +201,7 @@ ssl_connect(thread_t * thread, int new_req)
#3  		req->bio = BIO_new_socket(thread->u.fd, BIO_NOCLOSE);
#3  		BIO_get_fd(req->bio, &bio_fd);
#3  		fcntl(bio_fd, F_SETFD, fcntl(bio_fd, F_GETFD) | FD_CLOEXEC);
#3 +// Use SSL_set0_rbio() and SSL_set0_wbio() instead of SSL_set_bio()
#3  		SSL_set_bio(req->ssl, req->bio, req->bio);
#3  	}
#3  
#5 diff --git a/keepalived/core/daemon.c b/keepalived/core/daemon.c
#5 index a8ec37ec..8dc9a5b9 100644
#5 --- a/keepalived/core/daemon.c
#5 +++ b/keepalived/core/daemon.c
#5 @@ -29,7 +29,7 @@
#5  
#5  /* Daemonization function coming from zebra source code */
#5  pid_t
#5 -xdaemon(int nochdir, int noclose, int exitflag)
#5 +xdaemon(bool nochdir, bool noclose, bool exitflag)
#5  {
#5  	pid_t pid;
#5  	int ret;
#5 @@ -65,8 +65,8 @@ xdaemon(int nochdir, int noclose, int exitflag)
#5  	}
#5  
#5  	/* File descriptor close. */
#5 -	if (!noclose)
#5 -		set_std_fd(true);
#5 +//	if (!noclose)
#5 +//		set_std_fd(true);
#5  
#5  	return 0;
#5  }
#2 diff --git a/keepalived/core/keepalived_netlink.c b/keepalived/core/keepalived_netlink.c
#2 index ad0befb4..f9c29785 100644
#2 --- a/keepalived/core/keepalived_netlink.c
#2 +++ b/keepalived/core/keepalived_netlink.c
#2 @@ -811,6 +811,7 @@ netlink_request(nl_handle_t *nl, unsigned char family, uint16_t type)
#2  
#2  	/* Cleanup the room */
#2  	memset(&snl, 0, sizeof (snl));
#2 +	memset(&req, 0, sizeof (req));
#2  	snl.nl_family = AF_NETLINK;
#2  
#2  	req.nlh.nlmsg_len = sizeof (req);
#1 diff --git a/keepalived/core/main.c b/keepalived/core/main.c
#1 index d9e4125b..e16a7d00 100644
#1 --- a/keepalived/core/main.c
#1 +++ b/keepalived/core/main.c
#1 @@ -36,6 +36,7 @@
#1  #include "main.h"
#1  #include "config.h"
#1  #include "git-commit.h"
#1 +#include "utils.h"
#1  #include "signals.h"
#1  #include "pidfile.h"
#1  #include "bitops.h"
#1 @@ -980,8 +981,15 @@ keepalived_main(int argc, char **argv)
#1  	}
#1  
#1  	/* daemonize process */
#1 -	if (!__test_bit(DONT_FORK_BIT, &debug))
#1 -		xdaemon(0, 0, 0);
#1 +	if (!__test_bit(DONT_FORK_BIT, &debug)) {
#1 +		close_std_fd();
#1 +		if (xdaemon(false, false, true) > 0) {
#1 +			closelog();
#1 +			FREE(config_id);
#1 +			FREE(orig_core_dump_pattern);
#1 +			exit(0);
#1 +		}
#1 +	}
#1  
#1  	/* Set file creation mask */
#1  	umask(0);
#1 @@ -1043,6 +1051,8 @@ end:
#1  
#1  	closelog();
#1  
#1 +	FREE(config_id);
#1 +
#1  #ifndef _MEM_CHECK_LOG_
#1  	FREE_PTR(syslog_ident);
#1  #else
#5 diff --git a/keepalived/include/daemon.h b/keepalived/include/daemon.h
#5 index 43bc5b4a..bd727ce6 100644
#5 --- a/keepalived/include/daemon.h
#5 +++ b/keepalived/include/daemon.h
#5 @@ -32,8 +32,9 @@
#5  #include <unistd.h>
#5  #include <errno.h>
#5  #include <fcntl.h>
#5 +#include <stdbool.h>
#5  
#5  /* prototype */
#5 -extern pid_t xdaemon(int, int, int);
#5 +extern pid_t xdaemon(bool, bool, bool);
#5  
#5  #endif
#1 diff --git a/keepalived/vrrp/vrrp_daemon.c b/keepalived/vrrp/vrrp_daemon.c
#1 index 677b0ee8..adf26add 100644
#1 --- a/keepalived/vrrp/vrrp_daemon.c
#1 +++ b/keepalived/vrrp/vrrp_daemon.c
#1 @@ -179,6 +179,8 @@ stop_vrrp(int status)
#1  
#1  	closelog();
#1  
#1 +	FREE(config_id);
#1 +
#1  #ifndef _MEM_CHECK_LOG_
#1  	FREE_PTR(vrrp_syslog_ident);
#1  #else
#1 diff --git a/lib/parser.c b/lib/parser.c
#1 index 6ed98374..e6d2f233 100644
#1 --- a/lib/parser.c
#1 +++ b/lib/parser.c
#1 @@ -33,6 +33,7 @@
#1  #include <sys/types.h>
#1  #include <fcntl.h>
#1  #include <stdbool.h>
#1 +#include <pwd.h>
#1  
#1  #include "parser.h"
#1  #include "memory.h"
#1 @@ -755,6 +756,9 @@ init_data(const char *conf_file, vector_t * (*init_keywords) (void))
#1  	read_conf_file(conf_file);
#1  	unregister_null_strvec_handler();
#1  
#1 +	/* Close the password database if it was opened */
#1 +	endpwent();
#1 +
#1  	free_keywords(keywords);
#1  	clear_rt_names();
#1  }
#6 diff --git a/lib/utils.c b/lib/utils.c
#6 index b9de9f00..db76e544 100644
#6 --- a/lib/utils.c
#6 +++ b/lib/utils.c
#6 @@ -534,7 +534,7 @@ string_equal(const char *str1, const char *str2)
#6  }
#6  
#6  void
#6 -set_std_fd(int force)
#6 +set_std_fd(bool force)
#6  {
#6  	int fd;
#6  
#6 @@ -552,6 +552,14 @@ set_std_fd(int force)
#6  	signal_pipe_close(STDERR_FILENO+1);
#6  }
#6  
#6 +void
#6 +close_std_fd(void)
#6 +{
#6 +	close(STDIN_FILENO);
#6 +	close(STDOUT_FILENO);
#6 +	close(STDERR_FILENO);
#6 +}
#6 +
#6  #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_
#6  int
#6  fork_exec(char **argv)
#6 diff --git a/lib/utils.h b/lib/utils.h
#6 index 5d0ae001..9850f2d9 100644
#6 --- a/lib/utils.h
#6 +++ b/lib/utils.h
#6 @@ -71,7 +71,8 @@ extern int inet_inaddrcmp(int, void *, void *);
#6  extern int inet_sockaddrcmp(struct sockaddr_storage *, struct sockaddr_storage *);
#6  extern char *get_local_name(void);
#6  extern int string_equal(const char *, const char *);
#6 -extern void set_std_fd(int);
#6 +extern void set_std_fd(bool);
#6 +extern void close_std_fd(void);
#6  #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_
#6  extern int fork_exec(char **argv);
#6  #endif
