#!/bin/bash

export LC_COLLATE=C

REVERSE=0
CMD=patch
FIRST=0
LAST=
EACH=
PATCH_LIST=
DIR=.
AMALGAMATE=0
PROMPT_CONT=0
POST_CMD=
NUM_PATCHES=
PATCH_FLAGS=

[[ -n $PATCH_DIR ]] && DIR=$PATCH_DIR

show_help()
{
	cat <<EOF
$0 - Usage:
	-h		Show this!
	-d directory	Patch directory name
	-r		Apply in reverse
	-e		Remove empty files after patch
	-f patch num	First patch
	-l patch num	Last patch
	-p patch_num	Only specified patch
	-A patch_num	Patches after patch_num (default only 1)
	-n num		Number of patches to apply (TODO)
	-c command	Command to execute
	-a		Amalgamate command processing
	-x		Command to execute after each patch
	-m		patch merge type
	-P		Prompt to continue
EOF
}

while getopts ":hd:rf:l:c:x:am:p:A:n:Pe" opt; do
	case $opt in
	h)
		show_help
		exit 0
		;;
	d)
		DIR=$OPTARG
		;;
	r)
		REVERSE=1
		;;
	e)
		PATCH_FLAGS+=" --remove-empty-files"
		;;
	f)
		FIRST=$OPTARG
		;;
	l)
		LAST=$OPTARG
		;;
	p)
		FIRST=$OPTARG
		LAST=$OPTARG
		;;
	A)
		FIRST=$((OPTARG+1))
		[[ -z $NUM_PATCHES ]] && NUM_PATCHES=1
		;;
	n)
		NUM_PATCHES=$OPTARG
		;;
	c)
		CMD=$OPTARG
		;;
	x)
		POST_CMD=$OPTARG
		;;
	a)
		AMALGAMATE=1
		;;
	m)
		PATCH_FLAGS+=" --merge=$OPTARG"
		;;
	P)
		PROMPT_CONT=1
		;;
        ?)
                echo Unknown option && show_help && exit 1
                ;;
        esac
done


[[ -z $LAST ]] && LAST=$(ls -1 $DIR/[0-9][0-9][0-9]-*.patch | tail -1 | sed -e "s:.*/::" -e "s/-.*//")

if [[ $REVERSE -eq 1 ]]; then
	PATCH_REV=R
	SORT_FLAG=-r
else
	PATCH_REV=
	SORT_FLAG=
fi

LAST_PATCH=none

process_patch()
{
	local PATCH_NAME=$1
	local patch

	patch=$(find $DIR -name "${PATCH_NAME}-*.patch" -o -name "${PATCH_NAME}[a-z]-*.patch" | sort -i | tail -1)
	LAST_PATCH=$PATCH_NAME

	if [[ $CMD = patch ]]; then
		echo -e "\nApplying $patch"
		patch $PATCH_FLAGS -${PATCH_REV}p1 <$patch
		[[ $? -ne 0 ]] && echo $patch failed && exit 1

		# If a command is specified, run it
		if [[ -n $POST_CMD ]]; then
		       eval $POST_CMD $patch
		       [[ $? -ne 0 ]] && echo $POST_CMD failed after patch $PATCH_NAME && exit 1
	       fi
	elif [[ $AMALGAMATE -eq 1 ]]; then
		PATCH_FILES="$PATCH_FILES $patch"
	else
		$CMD $patch
		if [[ $PROMPT_CONT -eq 1 ]]; then
			read -p "Do you wish to continue:" ANS
			[[ $ANS = "n" ]] && exit
		fi
	fi
}

process_sub_patches()
{
	local PATCH_NUM=$1
	local FILES SUB_PATCHES SUB_PATCH

	FILES=$(find ${DIR} -name "${PATCH_NUM}.[0-9]-*.patch" -o -name "${PATCH_NUM}.[0-9][a-z]-*.patch" 2>/dev/null)
	[[ -z $FILES ]] && return

	SUB_PATCHES=$(find $DIR -name "${PATCH_NUM}.[0-9]-*.patch" -o -name "${PATCH_NUM}.[0-9][a-z]-*.patch" | sed -e "s:.*/::" -e "s/-.*//" -e "s/[a-z]$//" | sort -u $SORT_FLAG)
	for SUB_PATCH in $SUB_PATCHES; do
		process_patch $SUB_PATCH
	done
}

# All patches are matched by ${DIR}/[0-9][0-9][0-9]{,[a-z],.[0-9]{,[a-z]}}-*.patch
for n in $(ls -1 ${DIR}/[0-9][0-9][0-9]-*.patch 2>/dev/null | sed -e "s:.*/::" -e "s/-.*//" | sort $SORT_FLAG -u); do
	[[ $n -ne 0 ]] && PATCH_NUM=$(<<<$n sed -e "s/^0*//") || PATCH_NUM=0
	if [[ $PATCH_NUM -lt $FIRST ]]; then
		[[ $REVERSE -eq 1 ]] && break || continue
	elif [[ $PATCH_NUM -gt $LAST ]]; then
		[[ $REVERSE -eq 1 ]] && continue || break
	fi

	PATCH_NUM=$n

	# Where there are sub-patches, - 000.1f 000.2e etc, they need to be done in reverse if reversing
	[[ $PATCH_REV = R ]] && process_sub_patches $PATCH_NUM

	FILES=$(find ${DIR} -name "${PATCH_NUM}-*.patch" -o -name "${PATCH_NUM}[a-z]-*.patch" 2>/dev/null)
	[[ -z $FILES ]] && continue

	process_patch $PATCH_NUM

	[[ $PATCH_REV != R ]] && process_sub_patches $PATCH_NUM

	[[ -n $NUM_PATCHES && $((--NUM_PATCHES)) -eq 0 ]] && break
done

[[ $AMALGAMATE -eq 1 ]] && $CMD $PATCH_FILES

echo -e "\n" Last patch num $LAST_PATCH
