diff --git a/keepalived/core/global_data.c b/keepalived/core/global_data.c
index 0b450358..beeb6357 100644
--- a/keepalived/core/global_data.c
+++ b/keepalived/core/global_data.c
@@ -522,6 +522,7 @@ dump_global_data(FILE *fp, data_t * data)
 	conf_write(fp, " vrrp_netlink_cmd_rcv_bufs_force = %u", global_data->vrrp_netlink_cmd_rcv_bufs_force);
 	conf_write(fp, " vrrp_netlink_monitor_rcv_bufs = %u", global_data->vrrp_netlink_monitor_rcv_bufs);
 	conf_write(fp, " vrrp_netlink_monitor_rcv_bufs_force = %u", global_data->vrrp_netlink_monitor_rcv_bufs_force);
+	conf_write(fp, " vrrp_rcv_buf = %u", global_data->vrrp_vrrp_rcv_bufs);
 #endif
 #ifdef _WITH_LVS_
 	conf_write(fp, " lvs_netlink_cmd_rcv_bufs = %u", global_data->lvs_netlink_cmd_rcv_bufs);
diff --git a/keepalived/core/global_parser.c b/keepalived/core/global_parser.c
index 0d10fac5..c3efe827 100644
--- a/keepalived/core/global_parser.c
+++ b/keepalived/core/global_parser.c
@@ -1092,6 +1092,20 @@ vrrp_netlink_cmd_rcv_bufs_force_handler(vector_t *strvec)
 
 	global_data->vrrp_netlink_cmd_rcv_bufs_force = res;
 }
+
+static void
+vrrp_rcv_bufs_handler(vector_t *strvec)
+{
+	unsigned val;
+
+	if (!strvec)
+		return;
+
+	val = get_netlink_rcv_bufs_size(strvec, "vrrp_rcv_bufs");
+
+	if (val)
+		global_data->vrrp_rcv_bufs = val;
+}
 #endif
 
 #ifdef _WITH_LVS_
@@ -1289,6 +1303,7 @@ init_global_keywords(bool global_active)
 	install_keyword("vrrp_netlink_cmd_rcv_bufs_force", &vrrp_netlink_cmd_rcv_bufs_force_handler);
 	install_keyword("vrrp_netlink_monitor_rcv_bufs", &vrrp_netlink_monitor_rcv_bufs_handler);
 	install_keyword("vrrp_netlink_monitor_rcv_bufs_force", &vrrp_netlink_monitor_rcv_bufs_force_handler);
+	install_keyword("vrrp_rcv_bufs", &vrrp_rcv_bufs_handler);
 #endif
 #ifdef _WITH_LVS_
 	install_keyword("lvs_netlink_cmd_rcv_bufs", &lvs_netlink_cmd_rcv_bufs_handler);
diff --git a/keepalived/include/global_data.h b/keepalived/include/global_data.h
index f60b080b..3e2361bb 100644
--- a/keepalived/include/global_data.h
+++ b/keepalived/include/global_data.h
@@ -188,6 +188,7 @@ typedef struct _data {
 	bool				vrrp_netlink_cmd_rcv_bufs_force;
 	unsigned			vrrp_netlink_monitor_rcv_bufs;
 	bool				vrrp_netlink_monitor_rcv_bufs_force;
+	unsigned			vrrp_rcv_bufs;
 #endif
 #ifdef _WITH_LVS_
 	unsigned			lvs_netlink_cmd_rcv_bufs;
diff --git a/keepalived/include/vrrp.h b/keepalived/include/vrrp.h
index 3dc5295c..ad8cfb9a 100644
--- a/keepalived/include/vrrp.h
+++ b/keepalived/include/vrrp.h
@@ -286,6 +286,7 @@ typedef struct _vrrp_t {
 	size_t			send_buffer_size;
 	uint32_t		ipv4_csum;		/* Checksum ip IPv4 pseudo header for VRRPv3 */
 
+	unsigned		rcv_bufs;		/* Size of advert receive buffer for this vrrp instance.
 #if defined _WITH_VRRP_AUTH_
 	/* Authentication data (only valid for VRRPv2) */
 	uint8_t			auth_type;		/* authentification type. VRRP_AUTH_* */
diff --git a/keepalived/include/vrrp_if.h b/keepalived/include/vrrp_if.h
index 5f3f8380..b4a4eea6 100644
--- a/keepalived/include/vrrp_if.h
+++ b/keepalived/include/vrrp_if.h
@@ -91,6 +91,7 @@ typedef struct _interface {
 	ifindex_t		base_ifindex;		/* Only used at startup if we find vmac i/f before base i/f */
 	struct _interface	*base_ifp;		/* Base interface (if interface is a VMAC interface),
 							   otherwise the physical interface */
+	unsigned		vrrp_rcv_bufs;		/* Size of advert socket receive buffer */
 #endif
 	garp_delay_t		*garp_delay;		/* Delays for sending gratuitous ARP/NA */
 	bool			gna_router;		/* Router flag for NA messages */
diff --git a/keepalived/vrrp/vrrp.c b/keepalived/vrrp/vrrp.c
index cc0a6238..6f8d2596 100644
--- a/keepalived/vrrp/vrrp.c
+++ b/keepalived/vrrp/vrrp.c
@@ -2107,6 +2107,23 @@ int
 open_vrrp_read_socket(sa_family_t family, int proto, interface_t *ifp, bool unicast)
 {
 	int fd = -1;
+	int ret;
+	int val = 212992 / 2;
+	socklen_t len = sizeof(val);
+#if 0
+1. Do sockets get closed at reload, and if so is it all of them or just those no longer wanted
+2. Calculate buffer size either using mtu, or calc from no addr * addr_len + overhead
+3. Aggregate non VMAC on interfaces.
+4. Is anything needed for reload
+5. Function to calculate packet size - also used when moving VIPs to eVIPs
+6. SNDBUF should default to 1 advert per vrrp_instance on socket
+7. RCVBUF should default to 4 adverts per vrrp_instance on socket
+8. vrrp_rcv_buf and rcv_buf can be specified as "n adverts" (store as -n)
+9. Translate -ve to size of advert * (-n)
+10. If multiple vrrp instances use same socket, then sum of sizes (any not specified = 0)
+11. If all 0, then set all to default (vrrp_rcv_buf or if 0 see 6 and 7) and sum
+12. In vrrp_open_sockpool/vrrp_create_sockpool use a vector to temporarily hold sock sizes
+#endif
 
 	/* open the socket */
 	fd = socket(family, SOCK_RAW | SOCK_CLOEXEC, proto);
@@ -2119,6 +2136,11 @@ open_vrrp_read_socket(sa_family_t family, int proto, interface_t *ifp, bool unic
 	set_sock_flags(fd, F_SETFD, FD_CLOEXEC);
 #endif
 
+	ret = setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &val, len);
+	ret = getsockopt(fd, SOL_SOCKET, SO_RCVBUF, &val, &len);
+	if (val != 212992)
+		log_message(LOG_INFO, "vrrp receive socket buffer size set to %d, ret %d", val, ret);
+
 	/* Ensure no unwanted multicast packets are queued to this interface */
 	if (family == AF_INET)
 		if_setsockopt_mcast_all(family, &fd);
diff --git a/keepalived/vrrp/vrrp_data.c b/keepalived/vrrp/vrrp_data.c
index 9661d064..87a6c399 100644
--- a/keepalived/vrrp/vrrp_data.c
+++ b/keepalived/vrrp/vrrp_data.c
@@ -487,6 +487,8 @@ dump_vrrp(FILE *fp, void *data)
 
 	conf_write(fp, "   Using smtp notification = %s", vrrp->smtp_alert ? "yes" : "no");
 
+	conf_write(fp, "   Rcv bufs = %u", vrrp->rcv_bufs);
+
 	if (vrrp->script_backup)
 		dump_notify_script(fp, vrrp->script_backup, "Backup");
 	if (vrrp->script_master)
